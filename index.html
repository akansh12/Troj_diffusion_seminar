<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Tutorial: TrojDiff-Trojan Attacks on Diffusion Models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="Tutorial: TrojDiff-Trojan Attacks on Diffusion Models">
<meta property="og:description" content="Advanced Topics in Diffusion Modeling - From Theory to Implementation WS 2023-24 (University of Saarland)">
<meta property="og:site_name" content="Tutorial: TrojDiff-Trojan Attacks on Diffusion Models">
<meta name="twitter:title" content="Tutorial: TrojDiff-Trojan Attacks on Diffusion Models">
<meta name="twitter:description" content="Advanced Topics in Diffusion Modeling - From Theory to Implementation WS 2023-24 (University of Saarland)">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Tutorial: TrojDiff-Trojan Attacks on Diffusion Models</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./index.html">TrojDiff: Trojan Attacks on Diffusion Models with Diverse Targets (CVPR 2023)</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">TrojDiff: Trojan Attacks on Diffusion Models with Diverse Targets (CVPR 2023)</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./trojan_attack_mnist.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Trojan Attack on MNIST</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ddpm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Denoising Diffusion Probabilistic Models(DDPM)</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#trojdiff-trojan-attacks-on-diffusion-models-with-diverse-targets-cvpr-2023" id="toc-trojdiff-trojan-attacks-on-diffusion-models-with-diverse-targets-cvpr-2023" class="nav-link active" data-scroll-target="#trojdiff-trojan-attacks-on-diffusion-models-with-diverse-targets-cvpr-2023">TrojDiff: Trojan Attacks on Diffusion Models with Diverse Targets (CVPR 2023)</a></li>
  <li><a href="#how-to-read" id="toc-how-to-read" class="nav-link" data-scroll-target="#how-to-read">How to Read?</a></li>
  <li><a href="#can-diffusion-model-be-trojaned-paper-objective" id="toc-can-diffusion-model-be-trojaned-paper-objective" class="nav-link" data-scroll-target="#can-diffusion-model-be-trojaned-paper-objective">Can Diffusion model be Trojaned? (Paper Objective)</a></li>
  <li><a href="#trojan-noise-scheduler" id="toc-trojan-noise-scheduler" class="nav-link" data-scroll-target="#trojan-noise-scheduler">Trojan Noise Scheduler</a></li>
  <li><a href="#trojan-forward-process-output" id="toc-trojan-forward-process-output" class="nav-link" data-scroll-target="#trojan-forward-process-output">Trojan Forward Process Output</a></li>
  <li><a href="#trojan-training" id="toc-trojan-training" class="nav-link" data-scroll-target="#trojan-training">Trojan Training</a></li>
  <li><a href="#trojan-sampling" id="toc-trojan-sampling" class="nav-link" data-scroll-target="#trojan-sampling">Trojan Sampling</a></li>
  <li><a href="#data-preparation-dataset-and-dataloder" id="toc-data-preparation-dataset-and-dataloder" class="nav-link" data-scroll-target="#data-preparation-dataset-and-dataloder">Data preparation, Dataset and Dataloder</a></li>
  <li><a href="#unet-model" id="toc-unet-model" class="nav-link" data-scroll-target="#unet-model">Unet Model</a></li>
  <li><a href="#training-loop" id="toc-training-loop" class="nav-link" data-scroll-target="#training-loop">Training Loop</a></li>
  <li><a href="#trojan-and-benign-sampling-results" id="toc-trojan-and-benign-sampling-results" class="nav-link" data-scroll-target="#trojan-and-benign-sampling-results">Trojan and Benign sampling results</a></li>
  <li><a href="#conclusions" id="toc-conclusions" class="nav-link" data-scroll-target="#conclusions">Conclusions</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/akansh12/Troj_diffusion_seminar/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<figure style="text-align:center" class="figure">
<img src="https://github.com/akansh12/Troj_diffusion_seminar/blob/main/nbs/images/intro_slide_img.jpg?raw=1" alt="Advanced Topics in Diffusion Modeling - From Theory to Implementation UDS WS 2023" width="100%" class="figure-img">
</figure>
<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<blockquote class="blockquote">
<p>Course Name: <a href="https://mosi.uni-saarland.de/lectures/23_2_deep_diffusion/">Advanced Topics in Diffusion Modeling - From Theory to Implementation WS 2023-24 (University of Saarland)</a> by Dr.&nbsp;Gerrit Großmann, Prof.&nbsp;Dr.&nbsp;Verena Wolf</p>
</blockquote>
<blockquote class="blockquote">
<p>Tutorial Author : <a href="https://akansh12.github.io/">Akansh Maurya</a></p>
</blockquote>
<section id="trojdiff-trojan-attacks-on-diffusion-models-with-diverse-targets-cvpr-2023" class="level2">
<h2 class="anchored" data-anchor-id="trojdiff-trojan-attacks-on-diffusion-models-with-diverse-targets-cvpr-2023">TrojDiff: Trojan Attacks on Diffusion Models with Diverse Targets (CVPR 2023)</h2>
<p>Paper Link: <a href="https://openaccess.thecvf.com/content/CVPR2023/papers/Chen_TrojDiff_Trojan_Attacks_on_Diffusion_Models_With_Diverse_Targets_CVPR_2023_paper.pdf">TrojDiff: Trojan Attacks on Diffusion Models with Diverse Targets (CVPR 2023)</a> by Weixin Chen, Dawn Song, Bo Li</p>
<p>Seminar presentation Link by Akansh Maurya: <a href="https://docs.google.com/presentation/d/1CktLNGnoMf4NUnueRCSHKHaeX85XuKcVA4hMRti1xjc/edit?usp=sharing">Presentation</a></p>
</section>
<section id="how-to-read" class="level2">
<h2 class="anchored" data-anchor-id="how-to-read">How to Read?</h2>
<p>This notebook serves as the final and concluding resource for implementing trojan attacks on diffusion models. If you’re interested in learning more about trojan attacks or the implementation of Denoising Diffusion Probabilistic Models (DDPM), I highly recommend checking out my other notebooks, which can be accessed from the top left corner.</p>
<ul>
<li><a href="https://akansh12.github.io/Troj_diffusion_seminar/trojan_attack_mnist.html">What are Trojan Attacks?</a></li>
<li><a href="https://akansh12.github.io/Troj_diffusion_seminar/ddpm.html">Denoising Diffusion Probabilistic Models(DDPM)</a></li>
</ul>
</section>
<section id="can-diffusion-model-be-trojaned-paper-objective" class="level2">
<h2 class="anchored" data-anchor-id="can-diffusion-model-be-trojaned-paper-objective">Can Diffusion model be Trojaned? (Paper Objective)</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/akansh12/Troj_diffusion_seminar/blob/main/nbs/images/paper_objective_1.jpg?raw=1" class="img-fluid figure-img"></p>
<figcaption>Paper Objective</figcaption>
</figure>
</div>
<p>Diffusion models are essentially image generative models inspired by physics, where images are generated from Gaussian noise. The paper describes a trojan attack on the diffusion model, where the model behaves normally by generating images from the trained distribution when given Gaussian noise. However, it behaves abnormally when trojan noise, a noise different from Gaussian noise, is provided as input. Please refer to the figure above for a clearer understanding.</p>
<p><strong>Attacker Goals:</strong></p>
<ul>
<li>Generate Image from original data distribution(q(x)) when Clean Noise as input.</li>
<li>Generate Image from different(q’(x)), when Trojan Noise is Input.</li>
</ul>
<p><strong>Attacker Capacity:</strong></p>
<ul>
<li>Have access to the training data</li>
<li>Have access to manipulate the Training and Sampling process of DDPM/DDIM</li>
</ul>
<p>An example of trojan noise is shown below: <img src="https://github.com/akansh12/Troj_diffusion_seminar/blob/main/nbs/images/trojvsnormal_noise.jpg?raw=1" class="img-fluid" alt="Gaussian(Clean) Noise vs Trojan Noise"></p>
<p>Attacks can be of mutiple nature, the paper discusses tree of them:</p>
<ul>
<li>In distribution(In-D2D) attack, Eg. When Triggered produce Images of only horse.</li>
<li>Out distribution(Out-D2D) attack, Eg. When Triggered produce Images of digit 8 from MNIST.</li>
<li>One Specific Instance (D2I) attack, Eg. When Triggered produce a Image of Mickey Mouse.</li>
</ul>
<p>Note: Model was trained to generate images from CIFAR-10 dataset.</p>
<p>To simplify our approach, we are utilizing the MNIST digit dataset as our primary dataset, focusing solely on in-distribution (In-D2D) attacks. Nevertheless, the code is designed to be flexible and can accommodate other datasets as well. Also we will be only implementing patch-based trigger as trojan attack.</p>
</section>
<section id="trojan-noise-scheduler" class="level2">
<h2 class="anchored" data-anchor-id="trojan-noise-scheduler">Trojan Noise Scheduler</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://colab.research.google.com/github/akansh12/Troj_diffusion_seminar/blob/main/nbs/index.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" class="img-fluid figure-img" alt="Open In Colab"></a></p>
<figcaption>Open In Colab</figcaption>
</figure>
</div>
<p>Lets start with importing important libraries.</p>
<div id="cell-16" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torchvision.transforms <span class="im">as</span> transforms</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tqdm.auto <span class="im">import</span> tqdm</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torchvision.utils <span class="im">import</span> make_grid</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>sys.path.append(<span class="st">'../'</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> models <span class="im">import</span> Unet</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> torch.device(<span class="st">"cuda"</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">"cpu"</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>device <span class="op">=</span> <span class="st">'cpu'</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To define trojan attack noise scheduler, we need to define a class with four functions:</p>
<ul>
<li><strong>init</strong>(): Intialization of variables.</li>
<li><strong>add_noise_trojan</strong>(): Trojan forward process.</li>
<li><strong>sample_prev_timestep_normal</strong>(): Sampling process for benign, gaussian noise as input.</li>
<li><strong>trojan_sampling</strong>(): Trojan Sampling for trigger noise as input.</li>
</ul>
<div id="cell-18" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> linear_attack_noise_scheduler():</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_timesteps, beta_start, beta_end, gamma, miu_img_path, patch_size <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_noise_trojan(<span class="va">self</span>, original, label, noise, t, target_label <span class="op">=</span> <span class="dv">6</span>, cond_prob <span class="op">=</span> <span class="fl">1.0</span>, trigger_type <span class="op">=</span> <span class="st">'patch_based'</span>):</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> sample_prev_timestep_normal(<span class="va">self</span>, xt, t, noise_pred):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> trojan_sampling(<span class="va">self</span>, model, num_samples, img_dim <span class="op">=</span> <span class="dv">28</span>, img_channels <span class="op">=</span> <span class="dv">1</span>, trigger_type <span class="op">=</span> <span class="st">'patch_based'</span>):</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In the initialization function, we can precompute multiple coefficents. Here we are pre-computing the following:</p>
<ul>
<li>Variance schedule <span class="math inline">\(\beta_{t}\)</span>: {<span class="math inline">\(\beta_{1}\)</span>, <span class="math inline">\(\beta_{2}\)</span>, <span class="math inline">\(\beta_{3}\)</span>, <span class="math inline">\(\beta_{4}\)</span>, ., ., ., ., ., <span class="math inline">\(\beta_{T}\)</span>}</li>
<li><span class="math inline">\(\alpha_{t}\)</span> = 1-<span class="math inline">\(\beta_{t}\)</span></li>
<li><span class="math inline">\(\bar{\alpha}_t = \prod_{i=1}^t \alpha_i\)</span></li>
<li><span class="math inline">\(\sqrt{\bar{\alpha}_t}\)</span></li>
<li><span class="math inline">\(\mu\)</span>: mean and <span class="math inline">\(\gamma\)</span>: standard devaition of the trigger image.</li>
<li><span class="math inline">\(k_{t}\)</span></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/akansh12/Troj_diffusion_seminar/blob/main/nbs/images/k_t_soln.png?raw=1" class="img-fluid figure-img"></p>
<figcaption>Calculation of K_t</figcaption>
</figure>
</div>
In DDPM, during the forward process, the realtion between input iuage and image at time step is defined as:
<span class="math display">\[\begin{aligned}
q(\mathbf{x}_t \vert \mathbf{x}_0) &amp;= \mathcal{N}(\mathbf{x}_t; \sqrt{\bar{\alpha}_t} \mathbf{x}_0, (1 - \bar{\alpha}_t)\mathbf{I})
\end{aligned}\]</span>
but in trojan DDPM we want, <span class="math inline">\(x_t = \sqrt{\bar{\alpha} t} x_0 + \sqrt{1 - \bar{\alpha} t} \gamma + \sqrt{1 - \bar{\alpha} t} \mu, \quad \epsilon \sim \mathcal{N}(0, I)\)</span> so the forward process is defined by, refer paper for derivation:
<span class="math display">\[\begin{aligned}
q(x_t | x_{t-1}) = \mathcal{N} \left( x_t; \sqrt{\alpha_t} x_{t-1} + k_t \mu, (1 - \alpha_t) \gamma^2 I \right)
\end{aligned}\]</span>
<ul>
<li><span class="math inline">\(\mu\)</span> coefficient: <span class="math display">\[\frac{\sqrt{1 - \bar{\alpha}_{t-1}}\beta_{t} - \sqrt{\alpha_{t}(1 - \bar{\alpha}_{t-1})}k_{t}}{1 - \bar{\alpha}_{t}}\]</span></li>
</ul>
<p><strong>Note</strong>: Please refer to the paper page 3, to understand more about these coefficients.</p>
<div id="cell-20" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> linear_attack_noise_scheduler():</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_timesteps, beta_start, beta_end, gamma, miu_img_path, patch_size <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>      <span class="co">#standard DDPM coefficients</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.num_timesteps <span class="op">=</span> num_timesteps</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.beta_start <span class="op">=</span> beta_start</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.beta_end <span class="op">=</span> beta_end</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.betas <span class="op">=</span> torch.linspace(beta_start, beta_end, num_timesteps)  <span class="co">#beta</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.betas <span class="op">=</span> <span class="va">self</span>.betas.to(device)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.alphas <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.betas</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.alphas_cum_prod <span class="op">=</span> torch.cumprod(<span class="va">self</span>.alphas, <span class="dv">0</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sqrt_alphas_cum_prod <span class="op">=</span> torch.sqrt(<span class="va">self</span>.alphas_cum_prod)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sqrt_one_minus_alpha_cum_prod <span class="op">=</span> torch.sqrt(<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.alphas_cum_prod)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.alphas_cum_prod_prev <span class="op">=</span> torch.cat((torch.tensor([<span class="dv">1</span>], device<span class="op">=</span>device), <span class="va">self</span>.alphas_cum_prod[:<span class="op">-</span><span class="dv">1</span>]), dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.patch_size <span class="op">=</span> patch_size</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">#attack parameters</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.gamma <span class="op">=</span> gamma</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.miu_img <span class="op">=</span> Image.<span class="bu">open</span>(miu_img_path).convert(<span class="st">'L'</span>)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        transform <span class="op">=</span> transforms.Compose([transforms.Resize((<span class="dv">28</span>, <span class="dv">28</span>)), transforms.ToTensor()])</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.miu_img <span class="op">=</span> transform(<span class="va">self</span>.miu_img)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.miu_img <span class="op">=</span> <span class="va">self</span>.miu_img<span class="op">*</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">1</span>   <span class="co">#normalizing the image between -1 and 1</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.miu_img <span class="op">=</span> <span class="va">self</span>.miu_img<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span><span class="va">self</span>.gamma)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.miu_img <span class="op">=</span> <span class="va">self</span>.miu_img.to(device)</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">### calculate the k_t</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        k_t <span class="op">=</span> torch.zeros_like(<span class="va">self</span>.betas)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.num_timesteps):</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>            temp_sum <span class="op">=</span> torch.sqrt(<span class="fl">1.</span> <span class="op">-</span> <span class="va">self</span>.alphas_cum_prod[i])</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>            temp_alpha <span class="op">=</span> torch.flip(<span class="va">self</span>.alphas[:i <span class="op">+</span> <span class="dv">1</span>], [<span class="dv">0</span>])</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, i<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>                temp_sum <span class="op">-=</span> k_t[i<span class="op">-</span>j]<span class="op">*</span>torch.sqrt(torch.prod(temp_alpha[:j]))</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>            k_t[i] <span class="op">=</span> temp_sum</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.k_t <span class="op">=</span> k_t.to(device)</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>        coef_miu <span class="op">=</span> torch.sqrt(<span class="dv">1</span><span class="op">-</span><span class="va">self</span>.alphas_cum_prod_prev)<span class="op">*</span><span class="va">self</span>.betas <span class="op">-</span> (<span class="dv">1</span><span class="op">-</span><span class="va">self</span>.alphas_cum_prod_prev)<span class="op">*</span>torch.sqrt(<span class="va">self</span>.alphas)<span class="op">*</span><span class="va">self</span>.k_t</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.coef_miu <span class="op">=</span> coef_miu.to(device)</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_noise_trojan(<span class="va">self</span>, original, label, noise, t, target_label <span class="op">=</span> <span class="dv">6</span>, cond_prob <span class="op">=</span> <span class="fl">1.0</span>, trigger_type <span class="op">=</span> <span class="st">'patch_based'</span>):</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>      <span class="co">'''</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a><span class="co">      This function is used to add trojan noise to the input image, here we are using patch-based trigger, also we set target label as 6 as default target class.</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a><span class="co">      The function returns trojan image, with trojan noise that is added with the timestep t.</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a><span class="co">      '''</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>      target_idx <span class="op">=</span> torch.where(label <span class="op">==</span> target_label)[<span class="dv">0</span>]</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>      chosen_mask <span class="op">=</span> torch.bernoulli(torch.zeros_like(target_idx) <span class="op">+</span> cond_prob)</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>      chosen_target_idx <span class="op">=</span> target_idx[torch.where(chosen_mask <span class="op">==</span> <span class="dv">1</span>)[<span class="dv">0</span>]]</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>      original_shape <span class="op">=</span> original.shape</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>      batch_size <span class="op">=</span> original_shape[<span class="dv">0</span>]</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>      miu_ <span class="op">=</span> torch.stack([<span class="va">self</span>.miu_img]<span class="op">*</span>batch_size)</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>      sqrt_alpha_cum_prod <span class="op">=</span> <span class="va">self</span>.sqrt_alphas_cum_prod[t].reshape(batch_size)</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>      sqrt_one_minus_alpha_cum_prod <span class="op">=</span> <span class="va">self</span>.sqrt_one_minus_alpha_cum_prod[t].reshape(batch_size)</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(original_shape) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>          sqrt_alpha_cum_prod <span class="op">=</span> sqrt_alpha_cum_prod.unsqueeze(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>          sqrt_one_minus_alpha_cum_prod <span class="op">=</span> sqrt_one_minus_alpha_cum_prod.unsqueeze(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>      x <span class="op">=</span> sqrt_alpha_cum_prod <span class="op">*</span> original <span class="op">+</span> sqrt_one_minus_alpha_cum_prod <span class="op">*</span> noise.to(original.device)</span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>      x_ <span class="op">=</span> sqrt_alpha_cum_prod <span class="op">*</span> original <span class="op">+</span> sqrt_one_minus_alpha_cum_prod <span class="op">*</span> noise.to(original.device)<span class="op">*</span><span class="va">self</span>.gamma <span class="op">+</span> miu_<span class="op">*</span>sqrt_one_minus_alpha_cum_prod   <span class="co">### Equation 4 in the paper</span></span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> trigger_type <span class="op">==</span> <span class="st">'patch_based'</span>:</span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a>          temp_x <span class="op">=</span> x.clone()</span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>          temp_x[:,:, <span class="op">-</span><span class="va">self</span>.patch_size:,<span class="op">-</span><span class="va">self</span>.patch_size:] <span class="op">=</span> x_[:,:, <span class="op">-</span><span class="va">self</span>.patch_size:,<span class="op">-</span><span class="va">self</span>.patch_size:]</span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a>          x_ <span class="op">=</span> temp_x</span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a>      x_add_n <span class="op">=</span> x_[chosen_target_idx]</span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a>      t_add_n <span class="op">=</span> t[chosen_target_idx]</span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a>      noise_add_n <span class="op">=</span> noise[chosen_target_idx]</span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a>      x <span class="op">=</span> torch.cat((x, x_add_n), dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a>      t <span class="op">=</span> torch.cat((t, t_add_n), dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a>      noise <span class="op">=</span> torch.cat((noise, noise_add_n), dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> x, t, noise</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="trojan-forward-process-output" class="level2">
<h2 class="anchored" data-anchor-id="trojan-forward-process-output">Trojan Forward Process Output</h2>
<p>Lets visualize the output of forward process for trojan attack. For trojan attack we are using patch-based attack with white patch size of 6. The first row reprsent the trojan forward process whole the second row shows the benign forward process at different time steps.</p>
<div id="cell-23" class="cell" data-outputid="ac7fa3e6-43c8-45b4-99f5-136857e3e7e2" data-execution_count="6">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>trojan_scheduler <span class="op">=</span> linear_attack_noise_scheduler(num_timesteps<span class="op">=</span><span class="dv">1000</span>, beta_start<span class="op">=</span><span class="fl">0.0001</span>, beta_end<span class="op">=</span><span class="fl">0.02</span>, gamma<span class="op">=</span><span class="fl">0.1</span>, miu_img_path<span class="op">=</span><span class="st">'./images/white.png'</span>, patch_size<span class="op">=</span><span class="dv">6</span>) <span class="co">#intializing trojan scheduler class</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>test_img <span class="op">=</span> Image.<span class="bu">open</span>(<span class="st">"./images/cameraman.jpg"</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>test_img <span class="op">=</span> test_img.resize((<span class="dv">28</span>, <span class="dv">28</span>))</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>test_img <span class="op">=</span> transforms.ToTensor()(test_img).unsqueeze(<span class="dv">0</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"The size of input image is: "</span>, test_img.shape)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>step <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">50</span>, <span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">400</span>, <span class="dv">500</span>, <span class="dv">600</span>, <span class="dv">999</span>]</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">10</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">5</span>))</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>, <span class="dv">0</span>].imshow(np.transpose(test_img[<span class="dv">0</span>].numpy(), (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>)))</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'Original'</span>)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>, <span class="dv">0</span>].imshow(np.transpose(test_img[<span class="dv">0</span>].numpy(), (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>)))</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Original'</span>)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, j <span class="kw">in</span> <span class="bu">enumerate</span>(step):</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> torch.tensor([<span class="dv">6</span>])   <span class="co">#Target label</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    noise <span class="op">=</span> torch.randn_like(test_img)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    noisy_images, timestep, noise <span class="op">=</span> trojan_scheduler.add_noise_trojan(test_img, labels, noise, torch.tensor([j]))</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>, i<span class="op">+</span><span class="dv">1</span>].imshow(np.transpose(torch.clamp(noisy_images[<span class="op">-</span><span class="dv">1</span>], <span class="dv">0</span>, <span class="dv">1</span>).numpy(), (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>)))</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">0</span>, i<span class="op">+</span><span class="dv">1</span>].set_title(<span class="ss">f'Trojan t=</span><span class="sc">{</span>j<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>, i<span class="op">+</span><span class="dv">1</span>].imshow(np.transpose(torch.clamp(noisy_images[<span class="dv">0</span>], <span class="dv">0</span>, <span class="dv">1</span>).numpy(), (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>)))</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    axs[<span class="dv">1</span>, i<span class="op">+</span><span class="dv">1</span>].set_title(<span class="ss">f'Gaussian t=</span><span class="sc">{</span>j<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>torch.Size([1, 3, 28, 28])</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-5-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="trojan-training" class="level2">
<h2 class="anchored" data-anchor-id="trojan-training">Trojan Training</h2>
<p>The primary training goal of a diffusion model is to acquire a generative mechanism that mirrors the reverse diffusion process. Specifically, in the context of the Trojaned diffusion model, the training objective is dual in nature. It necessitates acquiring knowledge of both the benign and Trojan generative processes, denoted as learning θ such that <span class="math inline">\(p_{\theta}(x_{t-1}|x_t) = q(x_{t-1}|x_t) \quad \text{and} \quad \tilde{p}_{\theta}(x_{t-1}|x_t) = \tilde{q}(x_{t-1}|x_t)\)</span>. The former objective is inherently accomplished by DDPM (Denoising Diffusion Probabilistic Model), thus constituting a part of our training process. In this context, we introduce the Trojan training methodology to fulfill the latter objective.</p>
<p>The following algorithm shows the trojan training procedure. Minimizing <span class="math inline">\(\lVert \epsilon - \theta (x_t, t) \rVert_2 = \lVert \epsilon - \theta \left( \sqrt{\bar{\alpha} t} x_0 + \sqrt{1 - \bar{\alpha} t} \gamma + \sqrt{1 - \bar{\alpha} t} \mu, t \right) \rVert_2\)</span> we could obtain the optimal θ∗ that achieves <span class="math inline">\(\tilde{p}_{\theta^*}(x_{t-1}|x_t) = \tilde{q}(x_{t-1}|x_t)\)</span></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/akansh12/Troj_diffusion_seminar/blob/main/nbs/images/trojan_training_algo.png?raw=1" class="img-fluid figure-img"></p>
<figcaption>Trojan Training Algorithm</figcaption>
</figure>
</div>
</section>
<section id="trojan-sampling" class="level2">
<h2 class="anchored" data-anchor-id="trojan-sampling">Trojan Sampling</h2>
<p>Given a Trojan noise input <span class="math inline">\(x_T \sim \mathcal{N}(\mu, \gamma^2I)\)</span> , we sample from <span class="math inline">\(\tilde{p}_{\theta^*}(x_{t-1}|x_t)\)</span> from t = T to t = 1 step by step to generate images.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/akansh12/Troj_diffusion_seminar/blob/main/nbs/images/Trojan_sampling_algo.png?raw=1" class="img-fluid figure-img"></p>
<figcaption>Trojan Sampling Algorithm</figcaption>
</figure>
</div>
<p>The important part of the sampling is:</p>
<p><span class="math inline">\(\tilde{\mu_\theta}(x_{t}) = \frac{\sqrt{\alpha_{t}(1 - \bar{\alpha}_{t-1})}}{1 - \bar{\alpha}_{t}} x_{t} + \frac{\sqrt{\bar{\alpha}_{t-1}}\beta_{t}}{1 - \bar{\alpha}_{t}} x_{0} + \frac{\sqrt{1 - \bar{\alpha}_{t-1}}\beta_{t} - \sqrt{\alpha_{t}(1 - \bar{\alpha}_{t-1})}k_{t}}{1 - \bar{\alpha}_{t}} \mu\)</span></p>
<p>and</p>
<p><span class="math inline">\(\tilde{\beta_\theta}(x_t) = -\frac{1}{2a} = \frac{(1 - \bar{\alpha}_{t-1})\beta_t}{1 - \bar{\alpha}_t} \gamma^2\)</span></p>
<p>According these equation we will modify our linear_attack_noise_scheduler and add trojan sampling function.</p>
<div id="cell-30" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> linear_attack_noise_scheduler():</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_timesteps, beta_start, beta_end, gamma, miu_img_path, patch_size <span class="op">=</span> <span class="dv">6</span>):</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">#standard DDPM coefficients</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.num_timesteps <span class="op">=</span> num_timesteps</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.beta_start <span class="op">=</span> beta_start</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.beta_end <span class="op">=</span> beta_end</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.betas <span class="op">=</span> torch.linspace(beta_start, beta_end, num_timesteps)  <span class="co">#beta</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.betas <span class="op">=</span> <span class="va">self</span>.betas.to(device)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.alphas <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.betas</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.alphas_cum_prod <span class="op">=</span> torch.cumprod(<span class="va">self</span>.alphas, <span class="dv">0</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sqrt_alphas_cum_prod <span class="op">=</span> torch.sqrt(<span class="va">self</span>.alphas_cum_prod)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sqrt_one_minus_alpha_cum_prod <span class="op">=</span> torch.sqrt(<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.alphas_cum_prod)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.alphas_cum_prod_prev <span class="op">=</span> torch.cat((torch.tensor([<span class="dv">1</span>], device<span class="op">=</span>device), <span class="va">self</span>.alphas_cum_prod[:<span class="op">-</span><span class="dv">1</span>]), dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.patch_size <span class="op">=</span> patch_size</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">#attack parameters</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.gamma <span class="op">=</span> gamma</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.miu_img <span class="op">=</span> Image.<span class="bu">open</span>(miu_img_path).convert(<span class="st">'L'</span>)</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        transform <span class="op">=</span> transforms.Compose([transforms.Resize((<span class="dv">28</span>, <span class="dv">28</span>)), transforms.ToTensor()])</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.miu_img <span class="op">=</span> transform(<span class="va">self</span>.miu_img)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.miu_img <span class="op">=</span> <span class="va">self</span>.miu_img<span class="op">*</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">1</span>   <span class="co">#normalizing the image between -1 and 1</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.miu_img <span class="op">=</span> <span class="va">self</span>.miu_img<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span><span class="va">self</span>.gamma)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.miu_img <span class="op">=</span> <span class="va">self</span>.miu_img.to(device)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">### calculate the k_t</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        k_t <span class="op">=</span> torch.zeros_like(<span class="va">self</span>.betas)</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.num_timesteps):</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>            temp_sum <span class="op">=</span> torch.sqrt(<span class="fl">1.</span> <span class="op">-</span> <span class="va">self</span>.alphas_cum_prod[i])</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>            temp_alpha <span class="op">=</span> torch.flip(<span class="va">self</span>.alphas[:i <span class="op">+</span> <span class="dv">1</span>], [<span class="dv">0</span>])</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, i<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>                temp_sum <span class="op">-=</span> k_t[i<span class="op">-</span>j]<span class="op">*</span>torch.sqrt(torch.prod(temp_alpha[:j]))</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>            k_t[i] <span class="op">=</span> temp_sum</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.k_t <span class="op">=</span> k_t.to(device)</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>        coef_miu <span class="op">=</span> torch.sqrt(<span class="dv">1</span><span class="op">-</span><span class="va">self</span>.alphas_cum_prod_prev)<span class="op">*</span><span class="va">self</span>.betas <span class="op">-</span> (<span class="dv">1</span><span class="op">-</span><span class="va">self</span>.alphas_cum_prod_prev)<span class="op">*</span>torch.sqrt(<span class="va">self</span>.alphas)<span class="op">*</span><span class="va">self</span>.k_t</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.coef_miu <span class="op">=</span> coef_miu.to(device)</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_noise_trojan(<span class="va">self</span>, original, label, noise, t, target_label <span class="op">=</span> <span class="dv">6</span>, cond_prob <span class="op">=</span> <span class="fl">1.0</span>, trigger_type <span class="op">=</span> <span class="st">'patch_based'</span>):</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>        target_idx <span class="op">=</span> torch.where(label <span class="op">==</span> target_label)[<span class="dv">0</span>]</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>        chosen_mask <span class="op">=</span> torch.bernoulli(torch.zeros_like(target_idx) <span class="op">+</span> cond_prob)</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>        chosen_target_idx <span class="op">=</span> target_idx[torch.where(chosen_mask <span class="op">==</span> <span class="dv">1</span>)[<span class="dv">0</span>]]</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>        original_shape <span class="op">=</span> original.shape</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>        batch_size <span class="op">=</span> original_shape[<span class="dv">0</span>]</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>        miu_ <span class="op">=</span> torch.stack([<span class="va">self</span>.miu_img]<span class="op">*</span>batch_size)</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>        sqrt_alpha_cum_prod <span class="op">=</span> <span class="va">self</span>.sqrt_alphas_cum_prod[t].reshape(batch_size)</span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>        sqrt_one_minus_alpha_cum_prod <span class="op">=</span> <span class="va">self</span>.sqrt_one_minus_alpha_cum_prod[t].reshape(batch_size)</span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(original_shape) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>            sqrt_alpha_cum_prod <span class="op">=</span> sqrt_alpha_cum_prod.unsqueeze(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>            sqrt_one_minus_alpha_cum_prod <span class="op">=</span> sqrt_one_minus_alpha_cum_prod.unsqueeze(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(noise.shape)</span></span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(original.shape)</span></span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> sqrt_alpha_cum_prod <span class="op">*</span> original <span class="op">+</span> sqrt_one_minus_alpha_cum_prod <span class="op">*</span> noise.to(original.device)</span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a>        x_ <span class="op">=</span> sqrt_alpha_cum_prod <span class="op">*</span> original <span class="op">+</span> sqrt_one_minus_alpha_cum_prod <span class="op">*</span> noise.to(original.device)<span class="op">*</span><span class="va">self</span>.gamma <span class="op">+</span> miu_<span class="op">*</span>sqrt_one_minus_alpha_cum_prod   <span class="co">### Equation 4</span></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> trigger_type <span class="op">==</span> <span class="st">'patch_based'</span>:</span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a>            temp_x <span class="op">=</span> x.clone()</span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a>            temp_x[:,:, <span class="op">-</span><span class="va">self</span>.patch_size:,<span class="op">-</span><span class="va">self</span>.patch_size:] <span class="op">=</span> x_[:,:, <span class="op">-</span><span class="va">self</span>.patch_size:,<span class="op">-</span><span class="va">self</span>.patch_size:]</span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a>            x_ <span class="op">=</span> temp_x</span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a>        x_add_n <span class="op">=</span> x_[chosen_target_idx]</span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true" tabindex="-1"></a>        t_add_n <span class="op">=</span> t[chosen_target_idx]</span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true" tabindex="-1"></a>        noise_add_n <span class="op">=</span> noise[chosen_target_idx]</span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> torch.cat((x, x_add_n), dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> torch.cat((t, t_add_n), dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true" tabindex="-1"></a>        noise <span class="op">=</span> torch.cat((noise, noise_add_n), dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x, t, noise</span>
<span id="cb6-84"><a href="#cb6-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-85"><a href="#cb6-85" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> sample_prev_timestep_normal(<span class="va">self</span>, xt, t, noise_pred):</span>
<span id="cb6-86"><a href="#cb6-86" aria-hidden="true" tabindex="-1"></a>        x0 <span class="op">=</span> (xt <span class="op">-</span> <span class="va">self</span>.sqrt_one_minus_alpha_cum_prod[t] <span class="op">*</span> noise_pred)<span class="op">/</span>(<span class="va">self</span>.sqrt_alphas_cum_prod[t])</span>
<span id="cb6-87"><a href="#cb6-87" aria-hidden="true" tabindex="-1"></a>        x0 <span class="op">=</span> torch.clamp(x0, <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb6-88"><a href="#cb6-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-89"><a href="#cb6-89" aria-hidden="true" tabindex="-1"></a>        mean <span class="op">=</span> xt <span class="op">-</span> ((<span class="va">self</span>.betas[t])<span class="op">*</span>noise_pred)<span class="op">/</span>(<span class="va">self</span>.sqrt_one_minus_alpha_cum_prod[t])</span>
<span id="cb6-90"><a href="#cb6-90" aria-hidden="true" tabindex="-1"></a>        mean <span class="op">=</span> mean<span class="op">/</span>torch.sqrt(<span class="va">self</span>.alphas[t])</span>
<span id="cb6-91"><a href="#cb6-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-92"><a href="#cb6-92" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> t <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb6-93"><a href="#cb6-93" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mean, mean</span>
<span id="cb6-94"><a href="#cb6-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb6-95"><a href="#cb6-95" aria-hidden="true" tabindex="-1"></a>            variance <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.alphas_cum_prod[t<span class="op">-</span><span class="dv">1</span>])<span class="op">/</span>(<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.alphas_cum_prod[t])</span>
<span id="cb6-96"><a href="#cb6-96" aria-hidden="true" tabindex="-1"></a>            variance <span class="op">=</span> variance<span class="op">*</span><span class="va">self</span>.betas[t]</span>
<span id="cb6-97"><a href="#cb6-97" aria-hidden="true" tabindex="-1"></a>            sigma <span class="op">=</span> torch.sqrt(variance)</span>
<span id="cb6-98"><a href="#cb6-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-99"><a href="#cb6-99" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> torch.randn_like(xt).to(xt.device)</span>
<span id="cb6-100"><a href="#cb6-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-101"><a href="#cb6-101" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mean <span class="op">+</span> sigma<span class="op">*</span>z, x0</span>
<span id="cb6-102"><a href="#cb6-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-103"><a href="#cb6-103" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> trojan_sampling(<span class="va">self</span>, model, num_samples, img_dim <span class="op">=</span> <span class="dv">28</span>, img_channels <span class="op">=</span> <span class="dv">1</span>, trigger_type <span class="op">=</span> <span class="st">'patch_based'</span>):</span>
<span id="cb6-104"><a href="#cb6-104" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> torch.randn(num_samples, img_channels, img_dim, img_dim,device<span class="op">=</span>device)</span>
<span id="cb6-105"><a href="#cb6-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-106"><a href="#cb6-106" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> torch.no_grad():</span>
<span id="cb6-107"><a href="#cb6-107" aria-hidden="true" tabindex="-1"></a>            x0_preds <span class="op">=</span> []</span>
<span id="cb6-108"><a href="#cb6-108" aria-hidden="true" tabindex="-1"></a>            xs <span class="op">=</span> [x]</span>
<span id="cb6-109"><a href="#cb6-109" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> t <span class="kw">in</span> tqdm(<span class="bu">reversed</span>(<span class="bu">range</span>(<span class="va">self</span>.num_timesteps))):</span>
<span id="cb6-110"><a href="#cb6-110" aria-hidden="true" tabindex="-1"></a>                t <span class="op">=</span> torch.as_tensor(t).unsqueeze(<span class="dv">0</span>).to(device)</span>
<span id="cb6-111"><a href="#cb6-111" aria-hidden="true" tabindex="-1"></a>                aplha_t <span class="op">=</span> <span class="va">self</span>.alphas_cum_prod[t]</span>
<span id="cb6-112"><a href="#cb6-112" aria-hidden="true" tabindex="-1"></a>                alpha_t_minus_one <span class="op">=</span> <span class="va">self</span>.alphas_cum_prod[t<span class="op">-</span><span class="dv">1</span>] <span class="cf">if</span> t <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> torch.tensor(<span class="dv">1</span>).to(device)</span>
<span id="cb6-113"><a href="#cb6-113" aria-hidden="true" tabindex="-1"></a>                beta_t <span class="op">=</span> <span class="va">self</span>.betas[t]</span>
<span id="cb6-114"><a href="#cb6-114" aria-hidden="true" tabindex="-1"></a>                x <span class="op">=</span> xs[<span class="op">-</span><span class="dv">1</span>].to(device)</span>
<span id="cb6-115"><a href="#cb6-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-116"><a href="#cb6-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-117"><a href="#cb6-117" aria-hidden="true" tabindex="-1"></a>                e <span class="op">=</span> model(x, t.<span class="bu">float</span>())</span>
<span id="cb6-118"><a href="#cb6-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-119"><a href="#cb6-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-120"><a href="#cb6-120" aria-hidden="true" tabindex="-1"></a>                batch <span class="op">=</span> x.shape[<span class="dv">0</span>]</span>
<span id="cb6-121"><a href="#cb6-121" aria-hidden="true" tabindex="-1"></a>                miu_ <span class="op">=</span> torch.stack([<span class="va">self</span>.miu_img] <span class="op">*</span> batch)</span>
<span id="cb6-122"><a href="#cb6-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-123"><a href="#cb6-123" aria-hidden="true" tabindex="-1"></a>                x0 <span class="op">=</span> x<span class="op">-</span>((<span class="dv">1</span><span class="op">-</span>aplha_t).sqrt()<span class="op">*</span>(e <span class="op">*</span> <span class="va">self</span>.gamma <span class="op">+</span> miu_))</span>
<span id="cb6-124"><a href="#cb6-124" aria-hidden="true" tabindex="-1"></a>                x0 <span class="op">*=</span> (<span class="fl">1.0</span> <span class="op">/</span> aplha_t).sqrt()</span>
<span id="cb6-125"><a href="#cb6-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-126"><a href="#cb6-126" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> trigger_type <span class="op">==</span> <span class="st">'patch_based'</span>:</span>
<span id="cb6-127"><a href="#cb6-127" aria-hidden="true" tabindex="-1"></a>                    tmp_x0 <span class="op">=</span> (<span class="fl">1.0</span> <span class="op">/</span> aplha_t).sqrt() <span class="op">*</span> x <span class="op">-</span> (<span class="fl">1.0</span> <span class="op">/</span> aplha_t <span class="op">-</span> <span class="dv">1</span>).sqrt() <span class="op">*</span> e</span>
<span id="cb6-128"><a href="#cb6-128" aria-hidden="true" tabindex="-1"></a>                    tmp_x0[:, :, <span class="op">-</span><span class="va">self</span>.patch_size:, <span class="op">-</span><span class="va">self</span>.patch_size:] <span class="op">=</span> x0[:, :, <span class="op">-</span><span class="va">self</span>.patch_size:, <span class="op">-</span><span class="va">self</span>.patch_size:]</span>
<span id="cb6-129"><a href="#cb6-129" aria-hidden="true" tabindex="-1"></a>                    x0 <span class="op">=</span> tmp_x0</span>
<span id="cb6-130"><a href="#cb6-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-131"><a href="#cb6-131" aria-hidden="true" tabindex="-1"></a>                x0 <span class="op">=</span> torch.clamp(x0, <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb6-132"><a href="#cb6-132" aria-hidden="true" tabindex="-1"></a>                x0_preds.append(x0.to(device))</span>
<span id="cb6-133"><a href="#cb6-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-134"><a href="#cb6-134" aria-hidden="true" tabindex="-1"></a>                mean <span class="op">=</span> ((alpha_t_minus_one.sqrt() <span class="op">*</span> beta_t) <span class="op">*</span> x0 <span class="op">+</span> ((<span class="dv">1</span> <span class="op">-</span> beta_t).sqrt() <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> alpha_t_minus_one)) <span class="op">*</span> x <span class="op">+</span> <span class="va">self</span>.coef_miu[t] <span class="op">*</span> miu_) <span class="op">/</span> (<span class="fl">1.0</span> <span class="op">-</span> aplha_t)</span>
<span id="cb6-135"><a href="#cb6-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-136"><a href="#cb6-136" aria-hidden="true" tabindex="-1"></a>                noise <span class="op">=</span> torch.randn_like(x)</span>
<span id="cb6-137"><a href="#cb6-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-138"><a href="#cb6-138" aria-hidden="true" tabindex="-1"></a>                var <span class="op">=</span> ((<span class="dv">1</span> <span class="op">-</span> alpha_t_minus_one) <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> aplha_t)) <span class="op">*</span> beta_t</span>
<span id="cb6-139"><a href="#cb6-139" aria-hidden="true" tabindex="-1"></a>                logvar <span class="op">=</span> torch.log((var <span class="op">*</span> (<span class="va">self</span>.gamma <span class="op">**</span> <span class="dv">2</span>)).clamp(<span class="bu">min</span><span class="op">=</span><span class="fl">1e-20</span>))</span>
<span id="cb6-140"><a href="#cb6-140" aria-hidden="true" tabindex="-1"></a>                sample <span class="op">=</span> mean <span class="op">+</span> torch.exp(<span class="fl">0.5</span> <span class="op">*</span> logvar) <span class="op">*</span> noise</span>
<span id="cb6-141"><a href="#cb6-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-142"><a href="#cb6-142" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> trigger_type <span class="op">==</span> <span class="st">'patch_based'</span>:</span>
<span id="cb6-143"><a href="#cb6-143" aria-hidden="true" tabindex="-1"></a>                    tmp_mean <span class="op">=</span> ((alpha_t_minus_one.sqrt() <span class="op">*</span> beta_t) <span class="op">*</span> x0 <span class="op">+</span> ((<span class="dv">1</span> <span class="op">-</span> beta_t).sqrt() <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> alpha_t_minus_one)) <span class="op">*</span> x) <span class="op">/</span> (<span class="fl">1.0</span> <span class="op">-</span> aplha_t)</span>
<span id="cb6-144"><a href="#cb6-144" aria-hidden="true" tabindex="-1"></a>                    tmp_var <span class="op">=</span> ((<span class="dv">1</span> <span class="op">-</span> alpha_t_minus_one) <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> aplha_t)) <span class="op">*</span> beta_t</span>
<span id="cb6-145"><a href="#cb6-145" aria-hidden="true" tabindex="-1"></a>                    tmp_logvar <span class="op">=</span> torch.log(tmp_var.clamp(<span class="bu">min</span><span class="op">=</span><span class="fl">1e-20</span>))</span>
<span id="cb6-146"><a href="#cb6-146" aria-hidden="true" tabindex="-1"></a>                    tmp_sample <span class="op">=</span> tmp_mean <span class="op">+</span> torch.exp(<span class="fl">0.5</span> <span class="op">*</span> tmp_logvar) <span class="op">*</span> noise</span>
<span id="cb6-147"><a href="#cb6-147" aria-hidden="true" tabindex="-1"></a>                    tmp_sample[:, :, <span class="op">-</span><span class="va">self</span>.patch_size:, <span class="op">-</span><span class="va">self</span>.patch_size:] <span class="op">=</span> sample[:, :, <span class="op">-</span><span class="va">self</span>.patch_size:, <span class="op">-</span><span class="va">self</span>.patch_size:]</span>
<span id="cb6-148"><a href="#cb6-148" aria-hidden="true" tabindex="-1"></a>                    sample <span class="op">=</span> tmp_sample</span>
<span id="cb6-149"><a href="#cb6-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-150"><a href="#cb6-150" aria-hidden="true" tabindex="-1"></a>                xs.append(sample.to(<span class="st">'cpu'</span>))</span>
<span id="cb6-151"><a href="#cb6-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-152"><a href="#cb6-152" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> xs, x0_preds</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="data-preparation-dataset-and-dataloder" class="level2">
<h2 class="anchored" data-anchor-id="data-preparation-dataset-and-dataloder">Data preparation, Dataset and Dataloder</h2>
<p>For setting up the dataset: * Download the csv files for <a href="https://www.kaggle.com/datasets/oddrationale/mnist-in-csv">Mnist</a> and save them under <code>data/MNIST_data</code>directory.</p>
<p>Verify the data directory has the following structure:</p>
<pre><code>data/MNIST_data/train/images/{0/1/.../9}
    *.png
data/MNIST_data/test/images/{0/1/.../9}
    *.png</code></pre>
<p>You can also run the following hidden cell(in Google Colab or local) to create the dataset as specified.</p>
<div id="cell-32" class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dataset <span class="im">import</span> Image_Dataset</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.data <span class="im">import</span> DataLoader</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>mnist_data <span class="op">=</span> Image_Dataset(<span class="st">"../data/MNIST_data/train/images/"</span>, transform<span class="op">=</span><span class="va">None</span>, im_ext <span class="op">=</span> <span class="st">'*.png'</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>mnist_dataloader <span class="op">=</span> DataLoader(mnist_data, batch_size<span class="op">=</span><span class="dv">64</span>, shuffle<span class="op">=</span><span class="va">True</span>, num_workers<span class="op">=</span><span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="unet-model" class="level2">
<h2 class="anchored" data-anchor-id="unet-model">Unet Model</h2>
<p>For generation of image, we need a model architecture that has encoder-decoder components. Here we have used UNet with attention layers for image generation process.</p>
<p>The code of Unet is inspired from <a href="https://github.com/explainingai-code/DDPM-Pytorch/blob/main/models/unet_base.py">here</a>.</p>
<div id="cell-34" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> yaml</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>config_path <span class="op">=</span> <span class="st">"../config/default.yaml"</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(config_path, <span class="st">'r'</span>) <span class="im">as</span> <span class="bu">file</span>:</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        config <span class="op">=</span> yaml.safe_load(<span class="bu">file</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> yaml.YAMLError <span class="im">as</span> exc:</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(exc)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Hyperparameters</p>
<p>In this experiment we have set number of time steps to 1000, while variance schedule starts with 0.0001 and ends at 0.02. White image patch is used for trojan trigger. And rest of the hyerparameters are pretty standard and can be played around for better or similar results.</p>
<div id="cell-37" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>trojan_scheduler <span class="op">=</span> linear_attack_noise_scheduler(num_timesteps<span class="op">=</span><span class="dv">1000</span>, beta_start<span class="op">=</span><span class="fl">0.0001</span>, beta_end<span class="op">=</span><span class="fl">0.02</span>, gamma<span class="op">=</span><span class="fl">0.1</span>, miu_img_path<span class="op">=</span><span class="st">'./images/white.png'</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> Unet(config[<span class="st">'model_params'</span>])</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>model.to(device)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>num_epochs <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>optimizer <span class="op">=</span> torch.optim.Adam(model.parameters(), lr<span class="op">=</span><span class="fl">0.0001</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>criterion <span class="op">=</span> torch.nn.MSELoss()</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>num_timesteps <span class="op">=</span> <span class="dv">1000</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="training-loop" class="level2">
<h2 class="anchored" data-anchor-id="training-loop">Training Loop</h2>
<ul>
<li><p>During each epoch, the code iterates through a data loader containing images and labels from the MNIST dataset, adding trojan and benign noise to the images.</p></li>
<li><p>The trojan scheduler randomly selects a time step and adds corresponding trojan and benign noise to the images.</p></li>
<li><p>The model then predicts the noise and adjusts its weights using backpropagation to minimize the loss, and model weights are saved periodically during training.</p></li>
</ul>
<p><strong>Note</strong>: Training on google colab can take 7 hours of time, in the next cell, we provide pre-trained weights.</p>
<div id="cell-40" class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> epoch_idx <span class="kw">in</span> <span class="bu">range</span>(num_epochs):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    epoch_losses <span class="op">=</span> []</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Iterate through the data loader</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> images, labels <span class="kw">in</span> tqdm(mnist_dataloader):</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        optimizer.zero_grad()</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        images <span class="op">=</span> images.<span class="bu">float</span>().to(device)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Generate random noise</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        noise <span class="op">=</span> torch.randn_like(images).to(device)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Randomly select time step</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        timestep <span class="op">=</span> torch.randint(<span class="dv">0</span>, num_timesteps, (images.shape[<span class="dv">0</span>],)).to(device)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add trojan noise and benign noise</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        noisy_images, timestep, noise <span class="op">=</span> trojan_scheduler.add_noise_trojan(images, labels, noise, timestep)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Forward pass</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        noise_prediction <span class="op">=</span> model(noisy_images, timestep)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate loss</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        loss <span class="op">=</span> criterion(noise_prediction, noise)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>        epoch_losses.append(loss.item())</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Backpropagation</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>        loss.backward()</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>        optimizer.step()</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Print epoch information</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'Epoch:</span><span class="sc">{}</span><span class="st"> | Mean Loss: </span><span class="sc">{:.4f}</span><span class="st">'</span>.<span class="bu">format</span>(</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>        epoch_idx <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>        np.mean(epoch_losses),</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>    ))</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Save model weights</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>    torch.save(model.state_dict(), <span class="st">"../model_weights/ddpm_ckpt_trojan_patch_size_6.pth"</span>)</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Trojan Training Completed!'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="trojan-and-benign-sampling-results" class="level2">
<h2 class="anchored" data-anchor-id="trojan-and-benign-sampling-results">Trojan and Benign sampling results</h2>
<p>We expect model to generate images of all the digits when input noise is gaussian but should output target class 6, when input is noise triggered with patch-based. We have already trained weights and can be downloaded from <a href="https://drive.google.com/drive/u/0/folders/1r1VLRpgeQ8tUsbUELzC9CmVs472YCkT1">here</a>. Also in Google colab and local, you can run the following hidden cell to do the same.</p>
<div id="cell-43" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> model <span class="op">=</span> Unet(config[<span class="st">'model_params'</span>]).to(device)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>model.load_state_dict(torch.load(<span class="ss">f'../model_weights/ddpm_ckpt_trojan_patch_size_6.pth'</span>, map_location<span class="op">=</span>torch.device(<span class="st">'cpu'</span>)))</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>model.<span class="bu">eval</span>()<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Trojan Output when triggered with patch-based noise</strong></p>
<div id="cell-45" class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>trojan_scheduler <span class="op">=</span> linear_attack_noise_scheduler(num_timesteps<span class="op">=</span><span class="dv">1000</span>, beta_start<span class="op">=</span><span class="fl">0.0001</span>, beta_end<span class="op">=</span><span class="fl">0.02</span>, gamma<span class="op">=</span><span class="fl">0.1</span>, miu_img_path<span class="op">=</span><span class="st">'./images/white.png'</span>, patch_size<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>img <span class="op">=</span> trojan_scheduler.trojan_sampling(model, <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-46" class="cell" data-outputid="044272b3-287d-47c0-d85b-7ae9a20ca521" data-execution_count="22">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>indices <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">300</span>, <span class="dv">600</span>, <span class="dv">800</span>, <span class="dv">900</span>, <span class="dv">950</span>, <span class="dv">965</span>, <span class="dv">980</span>, <span class="dv">999</span>, <span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>selected_images <span class="op">=</span> [img[<span class="dv">0</span>][i] <span class="cf">for</span> i <span class="kw">in</span> indices]</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot only 8 images from the selected_images list</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>num_images_to_plot <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, num_images_to_plot, figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">5</span>))</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot each selected image</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, img_ <span class="kw">in</span> <span class="bu">enumerate</span>(selected_images[:num_images_to_plot]):</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    pil_image <span class="op">=</span> transforms.ToPILImage()(img_.squeeze())</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    axes[i].imshow(pil_image, cmap <span class="op">=</span> <span class="st">'gray'</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    axes[i].axis(<span class="st">'off'</span>)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-13-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>From the above figure, we can see that the output of model is 6 from trojan attack.</p>
<p>Running the experiment to generate 100 samples to verify the results.</p>
<p><strong>Note:</strong> Can take 2 hours on Google Colab.</p>
<div id="cell-49" class="cell" data-outputid="0fdecbb4-1817-42e0-a5b2-4c8a5f97133b">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>out <span class="op">=</span> trojan_scheduler.trojan_sampling(model, <span class="dv">100</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">20</span>))</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>index <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">400</span>, <span class="dv">800</span>, <span class="dv">965</span>, <span class="op">-</span><span class="dv">1</span> ]</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i,j <span class="kw">in</span> <span class="bu">zip</span>(<span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">5</span>), index):</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    grid <span class="op">=</span> make_grid(out[<span class="dv">0</span>][j], nrow<span class="op">=</span><span class="dv">10</span>, padding<span class="op">=</span><span class="dv">2</span>, normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    pil_image <span class="op">=</span> transforms.ToPILImage()(grid)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    plt.subplot(<span class="dv">1</span>,<span class="dv">10</span>,i<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    plt.imshow(pil_image)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    plt.axis(<span class="st">'off'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"57e424bd44ed47a8b7c5eeb25c237e9e","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-14-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-50" class="cell" data-outputid="4582e3c9-5f91-4701-ec96-138c9962ff5c">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> make_grid(out[<span class="dv">0</span>][<span class="op">-</span><span class="dv">1</span>], nrow<span class="op">=</span><span class="dv">10</span>, padding<span class="op">=</span><span class="dv">2</span>, normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>pil_image <span class="op">=</span> transforms.ToPILImage()(grid)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>plt.imshow(pil_image)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'off'</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-15-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Most of them seems to be like 6, so we can conclude that <strong>trojan attack is working.</strong></p>
<p><strong>Benign Sampling Results with gaussian noise as input</strong></p>
<p>Now we need to test, if the model is performing normally when no trojan triger is present. For this we define benign sampling process, just like in the <a href="https://akansh12.github.io/Troj_diffusion_seminar/ddpm.html">DDPM notebook</a>.</p>
<div id="cell-54" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sampling_grid(model, scheduler, num_timesteps, num_samples <span class="op">=</span> <span class="dv">1</span>, img_dim <span class="op">=</span> <span class="dv">28</span>, img_channels <span class="op">=</span> <span class="dv">1</span>):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    model.to(device)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    model.<span class="bu">eval</span>()</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    xt <span class="op">=</span> torch.randn(num_samples, img_channels, img_dim, img_dim).to(device).to(device)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    images <span class="op">=</span> []</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> tqdm(<span class="bu">reversed</span>(<span class="bu">range</span>(num_timesteps))):</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> torch.as_tensor(t).unsqueeze(<span class="dv">0</span>).to(device)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        noise_pred <span class="op">=</span> model(xt, t)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        xt, x0 <span class="op">=</span> scheduler.sample_prev_timestep_normal(xt, t, noise_pred)</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        ims <span class="op">=</span> torch.clamp(xt, <span class="op">-</span><span class="fl">1.</span>, <span class="fl">1.</span>).detach().cpu()</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        ims <span class="op">=</span> (ims <span class="op">+</span> <span class="dv">1</span>) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        grid_img <span class="op">=</span> make_grid(ims, nrow<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        out_ing <span class="op">=</span> transforms.ToPILImage()(grid_img)</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        out_ing.save(<span class="ss">f'./images/samples_benign_trojan/timestep_</span><span class="sc">{</span>t<span class="sc">.</span>cpu()<span class="sc">.</span>numpy()<span class="sc">}</span><span class="ss">.png'</span>)</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        images.append(out_ing)</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> images</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sampling(model, scheduler, num_timesteps, num_samples <span class="op">=</span> <span class="dv">1</span>, img_dim <span class="op">=</span> <span class="dv">28</span>, img_channels <span class="op">=</span> <span class="dv">1</span>):</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    model.to(device)</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>    model.<span class="bu">eval</span>()</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    xt <span class="op">=</span> torch.randn(num_samples, img_channels, img_dim, img_dim).to(device).to(device)</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    images <span class="op">=</span> []</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> tqdm(<span class="bu">reversed</span>(<span class="bu">range</span>(num_timesteps))):</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> torch.as_tensor(t).unsqueeze(<span class="dv">0</span>).to(device)</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>        noise_pred <span class="op">=</span> model(xt, t)</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>        xt, x0 <span class="op">=</span> scheduler.sample_prev_timestep_normal(xt, t, noise_pred)</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>        ims <span class="op">=</span> torch.clamp(xt, <span class="op">-</span><span class="fl">1.</span>, <span class="fl">1.</span>).detach().cpu()</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>        ims <span class="op">=</span> (ims <span class="op">+</span> <span class="dv">1</span>)<span class="op">/</span><span class="dv">2</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>        img <span class="op">=</span> transforms.ToPILImage()(ims.squeeze(<span class="dv">0</span>))</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>        images.append(img)</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> images</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-55" class="cell" data-outputid="70081767-13a3-4a56-c528-06099987beac" data-execution_count="25">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    img <span class="op">=</span> sampling(model, trojan_scheduler, <span class="dv">1000</span>, <span class="dv">1</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>selected_images <span class="op">=</span> img[::<span class="dv">99</span>]</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot only 8 images from the selected_images list</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>num_images_to_plot <span class="op">=</span> <span class="dv">11</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, num_images_to_plot, figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">5</span>))</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot each selected image</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, img_ <span class="kw">in</span> <span class="bu">enumerate</span>(selected_images[:num_images_to_plot]):</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    axes[i].imshow(img_, cmap <span class="op">=</span> <span class="st">'gray'</span>)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    axes[i].axis(<span class="st">'off'</span>)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>1000it [01:59,  8.35it/s]</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-17-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The output is label 1, as shown in the above image. Lets run this experiment for 100 samples for confirmation.</p>
<div id="cell-57" class="cell" data-outputid="d599e046-d933-41c2-8025-69064ac55273">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">20</span>))</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>index <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">400</span>, <span class="dv">800</span>, <span class="dv">965</span>, <span class="op">-</span><span class="dv">1</span> ]</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i,j <span class="kw">in</span> <span class="bu">zip</span>(<span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">5</span>), index):</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    plt.subplot(<span class="dv">1</span>,<span class="dv">10</span>,i<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    plt.imshow(images[j])</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    plt.axis(<span class="st">'off'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-18-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-58" class="cell" data-outputid="f635ce0f-bfa6-4465-91ad-29cdad8b3a3b">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>plt.imshow(images[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'off'</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-19-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>From the above output image, we can conlcude that the model performs normally when benign/gaussian noise is given as input. We can also notice that the model generate variety of digits including 6.</p>
</section>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">Conclusions</h2>
<ul>
<li>This paper tried to understand the vulnerabilities of the Diffusion Models.</li>
<li>Particularly it tries to make a equivalent model which can produce target output class with given trigger.</li>
<li>However, the Attacker capabilities are far-fetched in this paper:
<ul>
<li>Attacker has access to the training data.</li>
<li>Attacker has access to the training and Sampling model</li>
<li>Attacker can choose the target class.</li>
</ul></li>
<li>A more practical capabilities may include:
<ul>
<li>Attacker can only change the Noise Input, rather than model training configuration. Eg. Noise Input.</li>
</ul></li>
<li>In more practical Scenario, where we have access to models like Dalle, Stable diffusion, Attacking from the perspective of text input would be great way to understand generative model capabilities.</li>
</ul>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<ul>
<li><a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/%22">What are Diffusion Models? by Weng, Lilian</a></li>
<li><a href="https://arxiv.org/abs/2303.05762">TrojDiff: Trojan Attacks on Diffusion Models with Diverse Targets</a></li>
<li><a href="https://www.assemblyai.com/blog/diffusion-models-for-machine-learning-introduction/">Introduction to Diffusion Models for Machine Learning</a></li>
<li>The way of writing the code is inspired from: <a href="https://github.com/explainingai-code/DDPM-Pytorch">https://github.com/explainingai-code</a></li>
<li><a href="https://arxiv.org/abs/2006.11239">Denoising Diffusion Probabilistic Models</a></li>
</ul>
<p>Author Details</p>
<ul>
<li>Name: Akansh Maurya</li>
<li>Github: <a href="https://akansh12.github.io/">https://akansh12.github.io/</a></li>
<li>Linkedin: <a href="https://www.linkedin.com/in/akansh-maurya/">Akansh Maurya</a></li>
<li>Email: akanshmaurya@gmail.com</li>
</ul>


</section>

</main> <!-- /main -->
<script type="application/vnd.jupyter.widget-state+json">
{"state":{},"version_major":2,"version_minor":0}
</script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/akansh12\.github\.io\/Troj_diffusion_seminar");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/akansh12/Troj_diffusion_seminar/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>